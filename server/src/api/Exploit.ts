import { ObjectType, Field, ID, Resolver, Query, Arg, InputType, Mutation, FieldResolver, Root, registerEnumType } from 'type-graphql';
import { model, Schema } from 'mongoose';

enum ExploitCategory {
    WEB = 'Web',
    SOCIAL_ENGINEERING = 'Social Engineering',
    REVERSE_ENGINEERING = 'Reverse Engineering',
    NETWORKING = 'Networking',
    FUN = 'Fun'
}

registerEnumType(ExploitCategory, {
    name: "ExploitCategory"
});

@ObjectType()
export default class Exploit {
    @Field(type => ID)
    id: string;

    @Field()
    name: string;

    @Field()
    description: string;

    @Field()
    shortDescription: string;

    @Field({nullable: true})
    video: string;

    @Field({nullable: true})
    sandbox: string;

    @Field(type => [ExploitCategory], {nullable: true})
    categories: ExploitCategory[];
}

export const ExploitModel = model('Exploit', new Schema({
    name: { type: String, unique: true },
    description: { type: String },
    video: { type: String },
    categories: { type: [String]},
    sandbox: { type: String },
    createdAt: { type: String },
    updatedAt: { type: String }
}))

@InputType()
class ExploitCreate {
    @Field()
    name: string;

    @Field()
    description: string;

    @Field()
    video: string;

    @Field()
    sandbox: string;

    @Field(type => [ExploitCategory], {nullable: true})
    categories: ExploitCategory[];
}

@InputType()
class ExploitUpdate {
    @Field({nullable: true})
    name: string;

    @Field({nullable: true})
    description: string;

    @Field({nullable: true})
    video: string;

    @Field({nullable: true})
    sandbox: string;

    @Field(type => [ExploitCategory], {nullable: true})
    categories: ExploitCategory[];
}

@Resolver(of => Exploit)
export class ExploitResolver {
    @Query(returns => Exploit)
    async exploit(@Arg("id") id: string){
        return ExploitModel.findById(id);
    }

    @Query(returns => [Exploit])
    async exploits(){
        return ExploitModel.find({});
    }

    @Mutation(returns => Exploit)
    async createExploit(@Arg("input") input: ExploitCreate) {
        return ExploitModel.create(input);
    }

    @Mutation(returns => Exploit)
    async updateExploit(@Arg("id") id: string, @Arg("input") input: ExploitUpdate){
        return ExploitModel.findByIdAndUpdate(id, input);
    }

    @Mutation(returns => Exploit)
    async deleteExploit(@Arg("id") id: string){
        return ExploitModel.findByIdAndDelete(id);
    }

    @FieldResolver()
    shortDescription(
        @Root() exploit: any
    ): string {
        let s: string = exploit.description.substring(0, 100);

        return s.substring(0, s.lastIndexOf(' ')) + ' ...';
    }
}